<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChronoQuest - Master Time, Save the Timeline</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2e 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 3px solid #00ffff;
            border-radius: 12px;
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.4),
                0 0 60px rgba(0, 255, 255, 0.2),
                inset 0 0 30px rgba(0, 0, 0, 0.5);
            background: #000;
        }
        
        canvas {
            display: block;
            border-radius: 9px;
        }
        
        .screen-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.92);
            color: white;
            text-align: center;
            border-radius: 9px;
            transition: opacity 0.5s;
        }
        
        .hidden { opacity: 0; pointer-events: none; }
        
        #titleScreen h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 42px;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #00ffff, #ff00ff, #ffff00, #00ffff);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow 3s linear infinite;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }
        
        @keyframes rainbow {
            0% { background-position: 0% 50%; }
            100% { background-position: 300% 50%; }
        }
        
        #titleScreen .subtitle {
            font-size: 14px;
            color: #888;
            margin-bottom: 50px;
            letter-spacing: 4px;
        }
        
        .menu-btn {
            padding: 18px 50px;
            font-size: 16px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            background: transparent;
            border: 2px solid #00ffff;
            color: #00ffff;
            cursor: pointer;
            margin: 8px;
            border-radius: 4px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .menu-btn:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff, 0 0 60px rgba(0, 255, 255, 0.5);
            transform: scale(1.05);
        }
        
        .menu-btn.secondary {
            border-color: #666;
            color: #666;
        }
        
        .menu-btn.secondary:hover {
            background: #666;
            color: #000;
            box-shadow: 0 0 20px #666;
        }
        
        .controls-box {
            margin-top: 40px;
            padding: 25px 40px;
            border: 1px solid #333;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.03);
        }
        
        .controls-box h3 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 12px;
            letter-spacing: 3px;
        }
        
        .control-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 11px;
            color: #888;
        }
        
        .control-key {
            background: #222;
            padding: 4px 12px;
            border-radius: 4px;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            font-size: 8px;
            margin-left: 20px;
        }
        
        #storyScreen .story-text {
            max-width: 600px;
            line-height: 2;
            font-size: 14px;
            color: #aaa;
            margin-bottom: 40px;
            padding: 0 20px;
        }
        
        #storyScreen .story-text span {
            color: #00ffff;
        }
        
        #levelIntro {
            background: rgba(0, 0, 0, 0.95);
        }
        
        #levelIntro h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: 14px;
            color: #666;
            margin-bottom: 10px;
            letter-spacing: 3px;
        }
        
        #levelIntro h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            margin-bottom: 30px;
        }
        
        #levelIntro .level-desc {
            color: #888;
            font-size: 13px;
            max-width: 500px;
            line-height: 1.8;
        }
        
        #pauseScreen h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 32px;
            color: #ffff00;
            margin-bottom: 40px;
        }
        
        #deathScreen h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 28px;
            color: #ff4444;
            margin-bottom: 15px;
        }
        
        #deathScreen .death-message {
            color: #888;
            margin-bottom: 30px;
            font-size: 13px;
        }
        
        #winScreen h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 24px;
            color: #00ff88;
            margin-bottom: 15px;
        }
        
        #winScreen .stats {
            margin: 30px 0;
            padding: 20px 40px;
            border: 1px solid #333;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.03);
        }
        
        #winScreen .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 14px;
        }
        
        #winScreen .stat-label { color: #888; }
        #winScreen .stat-value { color: #00ffff; font-weight: 700; }
        
        #victoryScreen h1 {
            font-family: 'Press Start 2P', cursive;
            font-size: 36px;
            background: linear-gradient(90deg, #ffff00, #ff8800, #ffff00);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: rainbow 2s linear infinite;
            margin-bottom: 20px;
        }
        
        #victoryScreen .victory-message {
            color: #888;
            font-size: 14px;
            max-width: 500px;
            line-height: 1.8;
            margin-bottom: 30px;
        }
        
        .final-score {
            font-size: 48px;
            color: #00ffff;
            font-weight: 900;
            margin: 20px 0;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }
        
        #tutorialOverlay {
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
        }
        
        #tutorialOverlay h2 {
            font-family: 'Press Start 2P', cursive;
            font-size: 18px;
            color: #00ffff;
            margin-bottom: 30px;
        }
        
        .tutorial-step {
            display: flex;
            align-items: center;
            margin: 15px 0;
            font-size: 13px;
        }
        
        .tutorial-icon {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            margin-right: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }
        
        .version-tag {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 10px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="game"></canvas>
        
        <!-- Title Screen -->
        <div id="titleScreen" class="screen-overlay">
            <h1>CHRONOQUEST</h1>
            <div class="subtitle">MASTER TIME • SAVE THE TIMELINE</div>
            <button class="menu-btn" onclick="showStory()">NEW GAME</button>
            <button class="menu-btn secondary" onclick="showControls()">HOW TO PLAY</button>
            <div class="version-tag">v1.0.0 | © 2025</div>
        </div>
        
        <!-- Story Screen -->
        <div id="storyScreen" class="screen-overlay hidden">
            <div class="story-text">
                The year is 2157. A catastrophic experiment at the <span>Temporal Research Institute</span> 
                has shattered the timeline, creating rifts across history.<br><br>
                You are <span>Agent Zero</span>, the last Chrono Guardian. Armed with experimental 
                <span>time manipulation technology</span>, you must travel through the ages to collect 
                <span>Temporal Fragments</span> and restore the timeline before reality collapses.<br><br>
                The fate of all existence rests in your hands.
            </div>
            <button class="menu-btn" onclick="startGame()">BEGIN MISSION</button>
        </div>
        
        <!-- Controls Screen -->
        <div id="controlsScreen" class="screen-overlay hidden">
            <div class="controls-box" style="min-width: 400px;">
                <h3>CONTROLS</h3>
                <div class="control-row">
                    <span>Move</span>
                    <span><span class="control-key">A</span><span class="control-key">D</span> or <span class="control-key">←</span><span class="control-key">→</span></span>
                </div>
                <div class="control-row">
                    <span>Jump</span>
                    <span><span class="control-key">W</span> or <span class="control-key">SPACE</span></span>
                </div>
                <div class="control-row">
                    <span>Time Slow</span>
                    <span><span class="control-key">SHIFT</span></span>
                </div>
                <div class="control-row">
                    <span>Time Rewind</span>
                    <span><span class="control-key">R</span></span>
                </div>
                <div class="control-row">
                    <span>Pause</span>
                    <span><span class="control-key">ESC</span></span>
                </div>
            </div>
            <button class="menu-btn" style="margin-top: 30px;" onclick="hideControls()">BACK</button>
        </div>
        
        <!-- Level Intro -->
        <div id="levelIntro" class="screen-overlay hidden">
            <h2 id="levelNumber">LEVEL 1</h2>
            <h1 id="levelName">PREHISTORIC ERA</h1>
            <p class="level-desc" id="levelDesc">Navigate the primordial landscape and collect the first Temporal Fragment.</p>
        </div>
        
        <!-- Pause Screen -->
        <div id="pauseScreen" class="screen-overlay hidden">
            <h1>PAUSED</h1>
            <button class="menu-btn" onclick="resumeGame()">RESUME</button>
            <button class="menu-btn secondary" onclick="restartLevel()">RESTART LEVEL</button>
            <button class="menu-btn secondary" onclick="quitToMenu()">QUIT TO MENU</button>
        </div>
        
        <!-- Death Screen -->
        <div id="deathScreen" class="screen-overlay hidden">
            <h1>TIMELINE COLLAPSED</h1>
            <p class="death-message">A temporal paradox has occurred. The timeline must be restored.</p>
            <button class="menu-btn" onclick="restartLevel()">TRY AGAIN</button>
            <button class="menu-btn secondary" onclick="quitToMenu()">QUIT TO MENU</button>
        </div>
        
        <!-- Level Complete Screen -->
        <div id="winScreen" class="screen-overlay hidden">
            <h1>FRAGMENT SECURED</h1>
            <div class="stats">
                <div class="stat-row">
                    <span class="stat-label">Time</span>
                    <span class="stat-value" id="levelTime">0:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Orbs Collected</span>
                    <span class="stat-value" id="levelOrbs">0/0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Level Score</span>
                    <span class="stat-value" id="levelScore">0</span>
                </div>
            </div>
            <button class="menu-btn" onclick="nextLevel()">CONTINUE</button>
        </div>
        
        <!-- Victory Screen -->
        <div id="victoryScreen" class="screen-overlay hidden">
            <h1>TIMELINE RESTORED</h1>
            <p class="victory-message">
                Against all odds, you've collected all Temporal Fragments and restored 
                the timeline. History is safe once more, thanks to you, Agent Zero.
            </p>
            <div style="color: #888; font-size: 12px;">FINAL SCORE</div>
            <div class="final-score" id="finalScore">0</div>
            <button class="menu-btn" onclick="quitToMenu()">MAIN MENU</button>
        </div>
    </div>

    <script>
// ============================================================================
// CHRONOQUEST - A Time-Manipulation Platformer
// ============================================================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const WIDTH = 900;
const HEIGHT = 550;
canvas.width = WIDTH;
canvas.height = HEIGHT;

// ============================================================================
// AUDIO SYSTEM
// ============================================================================
let audioCtx = null;

function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}

function playTone(freq, duration, type = 'square', volume = 0.08, delay = 0) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = type;
    gain.gain.setValueAtTime(0, audioCtx.currentTime + delay);
    gain.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + delay + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + delay + duration);
    osc.start(audioCtx.currentTime + delay);
    osc.stop(audioCtx.currentTime + delay + duration);
}

const SFX = {
    jump: () => { playTone(280, 0.1, 'square'); playTone(350, 0.1, 'square', 0.06, 0.05); },
    doubleJump: () => { playTone(400, 0.08, 'square'); playTone(500, 0.08, 'square', 0.06, 0.04); playTone(600, 0.08, 'square', 0.04, 0.08); },
    land: () => playTone(100, 0.05, 'triangle', 0.03),
    collect: () => { playTone(600, 0.08); playTone(800, 0.08, 'square', 0.06, 0.06); playTone(1000, 0.12, 'square', 0.04, 0.12); },
    hurt: () => { playTone(150, 0.2, 'sawtooth', 0.12); playTone(100, 0.2, 'sawtooth', 0.08, 0.1); },
    death: () => { playTone(200, 0.3, 'sawtooth', 0.1); playTone(150, 0.3, 'sawtooth', 0.08, 0.15); playTone(100, 0.4, 'sawtooth', 0.06, 0.3); },
    timeSlow: () => playTone(80, 0.15, 'sine', 0.06),
    timeResume: () => playTone(120, 0.1, 'sine', 0.04),
    rewind: () => { playTone(200, 0.06, 'sine', 0.05); playTone(180, 0.06, 'sine', 0.04, 0.03); },
    stomp: () => { playTone(300, 0.1, 'square'); playTone(200, 0.15, 'square', 0.08, 0.05); },
    portal: () => { [400, 500, 600, 700, 800].forEach((f, i) => playTone(f, 0.15, 'sine', 0.05, i * 0.08)); },
    levelComplete: () => { [523, 659, 784, 1047].forEach((f, i) => playTone(f, 0.25, 'square', 0.06, i * 0.12)); },
    victory: () => { 
        [523, 659, 784, 659, 784, 1047].forEach((f, i) => playTone(f, 0.2, 'square', 0.07, i * 0.15));
        [262, 330, 392, 523].forEach((f, i) => playTone(f, 0.4, 'triangle', 0.04, i * 0.15));
    },
    click: () => playTone(800, 0.05, 'square', 0.03),
    powerUp: () => { playTone(400, 0.1, 'sine'); playTone(600, 0.1, 'sine', 0.06, 0.08); playTone(800, 0.15, 'sine', 0.05, 0.16); },
    shoot: () => playTone(180, 0.08, 'sawtooth', 0.04),
};

// ============================================================================
// GAME STATE
// ============================================================================
let gameState = 'title';
let currentLevel = 0;
let totalScore = 0;
let levelStartTime = 0;
let levelTime = 0;
let screenShake = 0;
let screenFlash = 0;
let screenFlashColor = '#fff';

// Time mechanics
let timeScale = 1;
let targetTimeScale = 1;
let isRewinding = false;
let rewindBuffer = [];
const MAX_REWIND_FRAMES = 240;
let timeEnergy = 100;
const MAX_TIME_ENERGY = 100;

// Input
const keys = {};
const keysPressed = {};
document.addEventListener('keydown', e => {
    if (!keys[e.code]) keysPressed[e.code] = true;
    keys[e.code] = true;
    if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
    if (e.code === 'Escape' && gameState === 'playing') togglePause();
});
document.addEventListener('keyup', e => keys[e.code] = false);

// ============================================================================
// PARTICLE SYSTEM
// ============================================================================
let particles = [];

class Particle {
    constructor(x, y, vx, vy, color, life = 1, size = 3, type = 'square') {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.color = color; this.life = life; this.maxLife = life;
        this.size = size; this.type = type; this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = (Math.random() - 0.5) * 10;
    }
    
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vy += 400 * dt;
        this.life -= dt;
        this.rotation += this.rotationSpeed * dt;
        this.size *= 0.98;
    }
    
    draw() {
        const alpha = Math.pow(this.life / this.maxLife, 0.5);
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        
        if (this.type === 'square') {
            ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);
        } else if (this.type === 'circle') {
            ctx.beginPath();
            ctx.arc(0, 0, this.size/2, 0, Math.PI * 2);
            ctx.fill();
        } else if (this.type === 'star') {
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = (i * Math.PI * 2 / 5) - Math.PI / 2;
                const r = i % 2 === 0 ? this.size : this.size / 2;
                if (i === 0) ctx.moveTo(Math.cos(angle) * r, Math.sin(angle) * r);
                else ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
            }
            ctx.fill();
        }
        
        ctx.restore();
    }
}

function spawnParticles(x, y, color, count = 10, speed = 150, life = 0.6, size = 4, type = 'square') {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const spd = speed * (0.5 + Math.random() * 0.5);
        particles.push(new Particle(
            x + (Math.random() - 0.5) * 10,
            y + (Math.random() - 0.5) * 10,
            Math.cos(angle) * spd,
            Math.sin(angle) * spd - 50,
            color,
            life * (0.7 + Math.random() * 0.6),
            size * (0.5 + Math.random()),
            type
        ));
    }
}

function spawnTrail(x, y, color, vx = 0, vy = 0) {
    particles.push(new Particle(x, y, vx * 0.2, vy * 0.2, color, 0.3, 6, 'circle'));
}

// ============================================================================
// PLAYER
// ============================================================================
const player = {
    x: 50, y: 300, vx: 0, vy: 0,
    width: 28, height: 36,
    onGround: false,
    wasOnGround: false,
    health: 3,
    maxHealth: 3,
    invincible: 0,
    facingRight: true,
    jumpCount: 0,
    maxJumps: 2,
    animFrame: 0,
    animTimer: 0,
    state: 'idle', // idle, run, jump, fall
    coyoteTime: 0,
    jumpBuffer: 0,
};

function resetPlayer(spawnX, spawnY) {
    player.x = spawnX;
    player.y = spawnY;
    player.vx = 0;
    player.vy = 0;
    player.health = player.maxHealth;
    player.invincible = 0;
    player.onGround = false;
    player.jumpCount = 0;
    player.state = 'idle';
}

// ============================================================================
// LEVEL DATA
// ============================================================================
const levels = [
    {
        name: "PREHISTORIC ERA",
        subtitle: "65 Million Years Ago",
        description: "Navigate the primordial landscape. Beware of ancient predators.",
        bgGradient: ['#1a0a2e', '#2d1b4e', '#1a2a1a'],
        platformColor: '#3d2817',
        platformHighlight: '#5a3d23',
        accentColor: '#00ff88',
        enemyColor: '#8b4513',
        platforms: [
            {x: 0, y: 480, w: 250, h: 70},
            {x: 200, y: 400, w: 120, h: 25},
            {x: 380, y: 340, w: 140, h: 25},
            {x: 300, y: 250, w: 100, h: 25},
            {x: 500, y: 280, w: 150, h: 25},
            {x: 550, y: 180, w: 120, h: 25},
            {x: 700, y: 250, w: 100, h: 25},
            {x: 750, y: 400, w: 150, h: 150},
        ],
        enemies: [
            {x: 400, y: 300, type: 'walker', patrol: 100},
            {x: 530, y: 240, type: 'walker', patrol: 80},
        ],
        collectibles: [
            {x: 250, y: 360, type: 'orb'},
            {x: 420, y: 300, type: 'orb'},
            {x: 350, y: 210, type: 'orb'},
            {x: 600, y: 140, type: 'orb'},
            {x: 730, y: 210, type: 'orb'},
        ],
        hazards: [],
        goal: {x: 790, y: 330, w: 50, h: 70},
        spawn: {x: 60, y: 400},
        decorations: [
            {type: 'tree', x: 80, y: 480, scale: 1.2},
            {type: 'rock', x: 450, y: 480, scale: 0.8},
            {type: 'tree', x: 650, y: 480, scale: 1},
        ]
    },
    {
        name: "MEDIEVAL ERA",
        subtitle: "1247 AD",
        description: "Storm the ancient castle. Watch for archers on the ramparts.",
        bgGradient: ['#0f1a2e', '#1a2a4a', '#2a1a3a'],
        platformColor: '#4a4a5a',
        platformHighlight: '#6a6a7a',
        accentColor: '#ffaa00',
        enemyColor: '#5a2a2a',
        platforms: [
            {x: 0, y: 480, w: 180, h: 70},
            {x: 220, y: 420, w: 100, h: 25},
            {x: 150, y: 330, w: 120, h: 25},
            {x: 320, y: 260, w: 100, h: 25},
            {x: 200, y: 180, w: 80, h: 25},
            {x: 400, y: 350, w: 100, h: 25},
            {x: 520, y: 280, w: 80, h: 25},
            {x: 450, y: 180, w: 100, h: 25},
            {x: 620, y: 240, w: 80, h: 25},
            {x: 700, y: 320, w: 80, h: 25},
            {x: 780, y: 200, w: 120, h: 300},
        ],
        enemies: [
            {x: 170, y: 290, type: 'walker', patrol: 80},
            {x: 420, y: 310, type: 'walker', patrol: 60},
            {x: 480, y: 140, type: 'shooter'},
            {x: 720, y: 280, type: 'walker', patrol: 40},
        ],
        collectibles: [
            {x: 260, y: 380, type: 'orb'},
            {x: 180, y: 290, type: 'orb'},
            {x: 350, y: 220, type: 'orb'},
            {x: 230, y: 140, type: 'orb'},
            {x: 550, y: 240, type: 'orb'},
            {x: 650, y: 200, type: 'orb'},
        ],
        hazards: [
            {x: 350, y: 460, w: 50, h: 20, type: 'spikes'},
            {x: 550, y: 460, w: 70, h: 20, type: 'spikes'},
        ],
        goal: {x: 810, y: 130, w: 50, h: 70},
        spawn: {x: 60, y: 400},
        decorations: [
            {type: 'flag', x: 100, y: 480, scale: 1},
            {type: 'torch', x: 400, y: 350, scale: 1},
            {type: 'torch', x: 620, y: 240, scale: 1},
        ]
    },
    {
        name: "INDUSTRIAL ERA",
        subtitle: "1889 AD",
        description: "Navigate the steam-powered factory. Mind the moving machinery.",
        bgGradient: ['#1a1a1a', '#2a2a2a', '#1a1a2a'],
        platformColor: '#5a5a5a',
        platformHighlight: '#7a7a7a',
        accentColor: '#ff6600',
        enemyColor: '#4a3a2a',
        platforms: [
            {x: 0, y: 480, w: 150, h: 70},
            {x: 180, y: 400, w: 80, h: 25, moving: true, moveX: 80, speed: 1.2},
            {x: 320, y: 340, w: 100, h: 25},
            {x: 480, y: 400, w: 80, h: 25, moving: true, moveY: 80, speed: 1},
            {x: 350, y: 240, w: 80, h: 25, moving: true, moveX: 100, speed: 0.8},
            {x: 550, y: 280, w: 100, h: 25},
            {x: 500, y: 180, w: 80, h: 25},
            {x: 650, y: 320, w: 80, h: 25, moving: true, moveY: 100, speed: 1.5},
            {x: 750, y: 220, w: 150, h: 280},
        ],
        enemies: [
            {x: 350, y: 300, type: 'walker', patrol: 60},
            {x: 580, y: 240, type: 'shooter'},
            {x: 520, y: 140, type: 'walker', patrol: 40},
        ],
        collectibles: [
            {x: 220, y: 360, type: 'orb'},
            {x: 350, y: 300, type: 'orb'},
            {x: 510, y: 360, type: 'orb'},
            {x: 390, y: 200, type: 'orb'},
            {x: 530, y: 140, type: 'orb'},
            {x: 690, y: 280, type: 'orb'},
        ],
        hazards: [
            {x: 150, y: 460, w: 30, h: 20, type: 'spikes'},
            {x: 420, y: 460, w: 60, h: 20, type: 'spikes'},
            {x: 620, y: 460, w: 80, h: 20, type: 'spikes'},
        ],
        goal: {x: 800, y: 150, w: 50, h: 70},
        spawn: {x: 50, y: 400},
        decorations: [
            {type: 'gear', x: 200, y: 480, scale: 1.5},
            {type: 'gear', x: 500, y: 480, scale: 1.2},
            {type: 'pipe', x: 700, y: 400, scale: 1},
        ]
    },
    {
        name: "FUTURE ERA",
        subtitle: "2157 AD",
        description: "Return to the source of the catastrophe. Time itself is unstable here.",
        bgGradient: ['#0a0a1f', '#1a1a3f', '#0a1a2f'],
        platformColor: '#2a4a5a',
        platformHighlight: '#3a6a7a',
        accentColor: '#00ffff',
        enemyColor: '#3a2a4a',
        platforms: [
            {x: 0, y: 480, w: 120, h: 70},
            {x: 150, y: 400, w: 80, h: 25, moving: true, moveX: 60, speed: 1.5},
            {x: 280, y: 340, w: 100, h: 25},
            {x: 180, y: 260, w: 80, h: 25, moving: true, moveX: 80, speed: 1.2},
            {x: 350, y: 200, w: 80, h: 25},
            {x: 440, y: 300, w: 80, h: 25, moving: true, moveY: 80, speed: 1},
            {x: 540, y: 220, w: 100, h: 25},
            {x: 450, y: 130, w: 80, h: 25, moving: true, moveX: 100, speed: 0.8},
            {x: 650, y: 160, w: 80, h: 25, moving: true, moveY: 60, speed: 1.3},
            {x: 750, y: 100, w: 150, h: 400},
        ],
        enemies: [
            {x: 300, y: 300, type: 'walker', patrol: 60},
            {x: 380, y: 160, type: 'shooter'},
            {x: 560, y: 180, type: 'walker', patrol: 60},
            {x: 480, y: 90, type: 'shooter'},
        ],
        collectibles: [
            {x: 190, y: 360, type: 'orb'},
            {x: 310, y: 300, type: 'orb'},
            {x: 220, y: 220, type: 'orb'},
            {x: 380, y: 160, type: 'orb'},
            {x: 480, y: 260, type: 'orb'},
            {x: 570, y: 180, type: 'orb'},
            {x: 500, y: 90, type: 'orb'},
            {x: 690, y: 120, type: 'orb'},
        ],
        hazards: [
            {x: 120, y: 460, w: 30, h: 20, type: 'spikes'},
            {x: 380, y: 460, w: 60, h: 20, type: 'spikes'},
            {x: 530, y: 460, w: 100, h: 20, type: 'spikes'},
            {x: 700, y: 460, w: 50, h: 20, type: 'spikes'},
        ],
        goal: {x: 790, y: 30, w: 50, h: 70},
        spawn: {x: 40, y: 400},
        decorations: [
            {type: 'hologram', x: 250, y: 340, scale: 1},
            {type: 'hologram', x: 550, y: 220, scale: 1},
        ],
        boss: false
    },
    {
        name: "TEMPORAL NEXUS",
        subtitle: "Outside of Time",
        description: "The heart of the timeline. Defeat the Temporal Anomaly to restore order.",
        bgGradient: ['#1a0020', '#300040', '#100030'],
        platformColor: '#4a3060',
        platformHighlight: '#6a4080',
        accentColor: '#ff00ff',
        enemyColor: '#600080',
        platforms: [
            {x: 0, y: 480, w: 900, h: 70},
            {x: 100, y: 380, w: 100, h: 25},
            {x: 300, y: 320, w: 100, h: 25},
            {x: 500, y: 320, w: 100, h: 25},
            {x: 700, y: 380, w: 100, h: 25},
            {x: 350, y: 220, w: 200, h: 25},
            {x: 200, y: 150, w: 80, h: 25, moving: true, moveX: 60, speed: 1},
            {x: 620, y: 150, w: 80, h: 25, moving: true, moveX: 60, speed: 1},
        ],
        enemies: [
            {x: 130, y: 340, type: 'walker', patrol: 60},
            {x: 530, y: 280, type: 'walker', patrol: 60},
            {x: 730, y: 340, type: 'walker', patrol: 60},
        ],
        collectibles: [
            {x: 140, y: 340, type: 'orb'},
            {x: 340, y: 280, type: 'orb'},
            {x: 540, y: 280, type: 'orb'},
            {x: 740, y: 340, type: 'orb'},
            {x: 240, y: 110, type: 'orb'},
            {x: 660, y: 110, type: 'orb'},
            {x: 440, y: 180, type: 'orb'},
        ],
        hazards: [],
        goal: {x: 425, y: 150, w: 50, h: 70},
        spawn: {x: 50, y: 400},
        decorations: [],
        boss: {
            x: 400, y: 100,
            health: 10,
            maxHealth: 10,
            phase: 1
        }
    }
];

let currentLevelData = null;
let platforms = [];
let enemies = [];
let collectibles = [];
let hazards = [];
let projectiles = [];
let platformPhases = [];
let boss = null;
let bossDefeated = false;
let collectedCount = 0;
let totalCollectibles = 0;

// ============================================================================
// LEVEL MANAGEMENT
// ============================================================================
function loadLevel(index) {
    currentLevel = index;
    currentLevelData = levels[index];
    
    resetPlayer(currentLevelData.spawn.x, currentLevelData.spawn.y);
    
    platforms = currentLevelData.platforms.map(p => ({
        ...p, origX: p.x, origY: p.y
    }));
    platformPhases = platforms.map(() => Math.random() * Math.PI * 2);
    
    enemies = currentLevelData.enemies.map(e => ({
        ...e,
        origX: e.x,
        vx: e.type === 'walker' ? 60 : 0,
        health: 1,
        shootTimer: e.type === 'shooter' ? 1.5 + Math.random() : 0,
        animTimer: 0
    }));
    
    collectibles = currentLevelData.collectibles.map(c => ({...c, collected: false}));
    totalCollectibles = collectibles.length;
    collectedCount = 0;
    
    hazards = currentLevelData.hazards || [];
    
    projectiles = [];
    particles = [];
    
    timeEnergy = MAX_TIME_ENERGY;
    timeScale = 1;
    targetTimeScale = 1;
    isRewinding = false;
    rewindBuffer = [];
    
    levelStartTime = performance.now();
    
    if (currentLevelData.boss) {
        boss = {...currentLevelData.boss};
        bossDefeated = false;
    } else {
        boss = null;
        bossDefeated = false;
    }
}

// ============================================================================
// SCREEN MANAGEMENT
// ============================================================================
function hideAllScreens() {
    document.querySelectorAll('.screen-overlay').forEach(s => s.classList.add('hidden'));
}

function showScreen(id) {
    hideAllScreens();
    document.getElementById(id).classList.remove('hidden');
}

function showStory() {
    SFX.click();
    showScreen('storyScreen');
}

function showControls() {
    SFX.click();
    showScreen('controlsScreen');
}

function hideControls() {
    SFX.click();
    showScreen('titleScreen');
}

function showLevelIntro() {
    const data = levels[currentLevel];
    document.getElementById('levelNumber').textContent = `LEVEL ${currentLevel + 1}`;
    document.getElementById('levelName').textContent = data.name;
    document.getElementById('levelName').style.color = data.accentColor;
    document.getElementById('levelDesc').textContent = data.description;
    showScreen('levelIntro');
    
    setTimeout(() => {
        hideAllScreens();
        gameState = 'playing';
    }, 2500);
}

function startGame() {
    initAudio();
    SFX.click();
    totalScore = 0;
    currentLevel = 0;
    loadLevel(0);
    showLevelIntro();
}

function togglePause() {
    if (gameState === 'playing') {
        gameState = 'paused';
        showScreen('pauseScreen');
    } else if (gameState === 'paused') {
        resumeGame();
    }
}

function resumeGame() {
    SFX.click();
    hideAllScreens();
    gameState = 'playing';
}

function restartLevel() {
    SFX.click();
    loadLevel(currentLevel);
    hideAllScreens();
    gameState = 'playing';
}

function quitToMenu() {
    SFX.click();
    gameState = 'title';
    showScreen('titleScreen');
}

function playerDeath() {
    SFX.death();
    gameState = 'dead';
    spawnParticles(player.x + player.width/2, player.y + player.height/2, '#ff0044', 40, 200, 1, 6);
    screenShake = 0.5;
    screenFlash = 0.3;
    screenFlashColor = '#ff0000';
    
    setTimeout(() => showScreen('deathScreen'), 500);
}

function levelComplete() {
    SFX.levelComplete();
    gameState = 'levelComplete';
    
    levelTime = (performance.now() - levelStartTime) / 1000;
    const timeBonus = Math.max(0, Math.floor((120 - levelTime) * 10));
    const orbBonus = collectedCount * 100;
    const levelScore = 500 + timeBonus + orbBonus;
    totalScore += levelScore;
    
    document.getElementById('levelTime').textContent = formatTime(levelTime);
    document.getElementById('levelOrbs').textContent = `${collectedCount}/${totalCollectibles}`;
    document.getElementById('levelScore').textContent = levelScore.toLocaleString();
    
    spawnParticles(player.x + player.width/2, player.y + player.height/2, currentLevelData.accentColor, 50, 250, 1.2, 8, 'star');
    screenFlash = 0.3;
    screenFlashColor = currentLevelData.accentColor;
    
    setTimeout(() => showScreen('winScreen'), 800);
}

function nextLevel() {
    SFX.click();
    if (currentLevel < levels.length - 1) {
        loadLevel(currentLevel + 1);
        showLevelIntro();
    } else {
        // Game complete!
        SFX.victory();
        document.getElementById('finalScore').textContent = totalScore.toLocaleString();
        showScreen('victoryScreen');
    }
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

// ============================================================================
// GAME UPDATE
// ============================================================================
function update(dt) {
    if (gameState !== 'playing') return;
    
    // Update level time
    levelTime = (performance.now() - levelStartTime) / 1000;
    
    // Time mechanics
    const wasSlowing = timeScale < 0.9;
    const wasRewinding = isRewinding;
    
    if ((keys['ShiftLeft'] || keys['ShiftRight']) && !keys['KeyR']) {
        if (timeEnergy > 0) {
            targetTimeScale = 0.25;
            timeEnergy -= 35 * dt;
            if (!wasSlowing) SFX.timeSlow();
            
            // Time slow particles
            if (Math.random() < 0.2) {
                spawnParticles(
                    player.x + player.width/2 + (Math.random() - 0.5) * 100,
                    player.y + player.height/2 + (Math.random() - 0.5) * 100,
                    '#00ffff', 1, 20, 0.5, 3, 'circle'
                );
            }
        } else {
            targetTimeScale = 1;
            if (wasSlowing) SFX.timeResume();
        }
        isRewinding = false;
    } else if (keys['KeyR']) {
        if (timeEnergy > 0 && rewindBuffer.length > 0) {
            isRewinding = true;
            timeEnergy -= 50 * dt;
            if (!wasRewinding) SFX.rewind();
        } else {
            isRewinding = false;
        }
        targetTimeScale = 1;
    } else {
        targetTimeScale = 1;
        isRewinding = false;
        if (wasSlowing) SFX.timeResume();
    }
    
    // Smooth time scale transition
    timeScale += (targetTimeScale - timeScale) * 10 * dt;
    
    // Recharge energy
    if (timeScale > 0.9 && !isRewinding) {
        timeEnergy = Math.min(MAX_TIME_ENERGY, timeEnergy + 20 * dt);
    }
    
    // Handle rewind
    if (isRewinding && rewindBuffer.length > 0) {
        const state = rewindBuffer.pop();
        player.x = state.x;
        player.y = state.y;
        player.vx = state.vx;
        player.vy = state.vy;
        player.onGround = state.onGround;
        
        if (Math.random() < 0.4) {
            spawnTrail(player.x + player.width/2, player.y + player.height/2, '#ff00ff');
        }
        
        // Also rewind enemies
        enemies.forEach((e, i) => {
            if (state.enemies && state.enemies[i]) {
                e.x = state.enemies[i].x;
                e.y = state.enemies[i].y;
            }
        });
        
        updateParticles(dt);
        return;
    }
    
    // Record state
    if (rewindBuffer.length >= MAX_REWIND_FRAMES) rewindBuffer.shift();
    rewindBuffer.push({
        x: player.x, y: player.y, vx: player.vx, vy: player.vy,
        onGround: player.onGround,
        enemies: enemies.map(e => ({x: e.x, y: e.y}))
    });
    
    const eDt = dt * timeScale;
    const gameTime = performance.now() / 1000;
    
    // Update moving platforms
    platforms.forEach((p, i) => {
        if (p.moving) {
            const phase = gameTime * p.speed * 2 + platformPhases[i];
            if (p.moveX) p.x = p.origX + Math.sin(phase) * p.moveX;
            if (p.moveY) p.y = p.origY + Math.sin(phase) * p.moveY;
        }
    });
    
    // Player physics
    const moveSpeed = 280;
    const jumpForce = -480;
    const gravity = 1400;
    const friction = 0.85;
    
    // Horizontal movement
    let moveInput = 0;
    if (keys['ArrowLeft'] || keys['KeyA']) { moveInput = -1; player.facingRight = false; }
    if (keys['ArrowRight'] || keys['KeyD']) { moveInput = 1; player.facingRight = true; }
    
    if (moveInput !== 0) {
        player.vx = moveInput * moveSpeed;
        if (player.onGround) player.state = 'run';
    } else {
        player.vx *= friction;
        if (player.onGround) player.state = 'idle';
    }
    
    // Coyote time and jump buffer
    if (player.onGround) {
        player.coyoteTime = 0.1;
        player.jumpCount = 0;
    } else {
        player.coyoteTime -= eDt;
    }
    
    if (keysPressed['ArrowUp'] || keysPressed['KeyW'] || keysPressed['Space']) {
        player.jumpBuffer = 0.1;
    }
    player.jumpBuffer -= eDt;
    
    // Jump logic
    if (player.jumpBuffer > 0) {
        if (player.coyoteTime > 0 || player.jumpCount < player.maxJumps) {
            if (player.coyoteTime > 0) {
                player.vy = jumpForce;
                player.jumpCount = 1;
                SFX.jump();
            } else if (player.jumpCount < player.maxJumps) {
                player.vy = jumpForce * 0.9;
                player.jumpCount++;
                SFX.doubleJump();
                spawnParticles(player.x + player.width/2, player.y + player.height, '#ffffff', 8, 100, 0.4, 4);
            }
            player.onGround = false;
            player.coyoteTime = 0;
            player.jumpBuffer = 0;
            player.state = 'jump';
            spawnParticles(player.x + player.width/2, player.y + player.height, '#ffffff', 6, 80, 0.3, 3);
        }
    }
    
    // Gravity
    player.vy += gravity * eDt;
    if (player.vy > 800) player.vy = 800;
    
    // Apply velocity
    player.x += player.vx * eDt;
    player.y += player.vy * eDt;
    
    // Update state
    if (!player.onGround) {
        player.state = player.vy < 0 ? 'jump' : 'fall';
    }
    
    // Animation
    player.animTimer += eDt;
    if (player.animTimer > 0.08) {
        player.animTimer = 0;
        player.animFrame = (player.animFrame + 1) % 8;
    }
    
    // Platform collision
    player.wasOnGround = player.onGround;
    player.onGround = false;
    
    for (const plat of platforms) {
        if (player.x + player.width > plat.x && player.x < plat.x + plat.w &&
            player.y + player.height > plat.y && player.y < plat.y + plat.h) {
            
            const overlapLeft = (player.x + player.width) - plat.x;
            const overlapRight = (plat.x + plat.w) - player.x;
            const overlapTop = (player.y + player.height) - plat.y;
            const overlapBottom = (plat.y + plat.h) - player.y;
            
            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
            
            if (minOverlap === overlapTop && player.vy >= 0) {
                player.y = plat.y - player.height;
                player.vy = 0;
                player.onGround = true;
                if (!player.wasOnGround) SFX.land();
            } else if (minOverlap === overlapBottom && player.vy < 0) {
                player.y = plat.y + plat.h;
                player.vy = 0;
            } else if (minOverlap === overlapLeft) {
                player.x = plat.x - player.width;
                player.vx = 0;
            } else if (minOverlap === overlapRight) {
                player.x = plat.x + plat.w;
                player.vx = 0;
            }
        }
    }
    
    // World bounds
    player.x = Math.max(0, Math.min(player.x, WIDTH - player.width));
    if (player.y > HEIGHT + 50) {
        playerDeath();
        return;
    }
    
    // Invincibility
    if (player.invincible > 0) player.invincible -= dt;
    
    // Hazard collision
    for (const haz of hazards) {
        if (player.x + player.width > haz.x && player.x < haz.x + haz.w &&
            player.y + player.height > haz.y && player.y < haz.y + haz.h) {
            if (player.invincible <= 0) {
                damagePlayer();
                if (player.health <= 0) return;
            }
        }
    }
    
    // Enemy update
    for (const enemy of enemies) {
        if (enemy.health <= 0) continue;
        
        enemy.animTimer += eDt;
        
        if (enemy.type === 'walker') {
            enemy.x += enemy.vx * eDt;
            
            // Patrol bounds
            if (enemy.patrol) {
                if (enemy.x < enemy.origX - enemy.patrol || enemy.x > enemy.origX + enemy.patrol) {
                    enemy.vx *= -1;
                }
            }
            
            // Platform edge detection
            let onPlat = false;
            for (const plat of platforms) {
                if (enemy.x + 10 > plat.x && enemy.x + 10 < plat.x + plat.w &&
                    Math.abs(enemy.y + 28 - plat.y) < 10) {
                    onPlat = true;
                    if (enemy.x < plat.x + 5 || enemy.x + 20 > plat.x + plat.w - 5) {
                        enemy.vx *= -1;
                    }
                    break;
                }
            }
        }
        
        if (enemy.type === 'shooter') {
            enemy.shootTimer -= eDt;
            if (enemy.shootTimer <= 0) {
                enemy.shootTimer = 1.5 + Math.random() * 0.5;
                const dx = player.x + player.width/2 - enemy.x - 12;
                const dy = player.y + player.height/2 - enemy.y - 12;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 400) {
                    projectiles.push({
                        x: enemy.x + 12, y: enemy.y + 12,
                        vx: (dx/dist) * 220, vy: (dy/dist) * 220,
                        hostile: true, life: 3
                    });
                    SFX.shoot();
                    spawnParticles(enemy.x + 12, enemy.y + 12, '#ff00ff', 5, 50, 0.2, 3);
                }
            }
        }
        
        // Enemy-player collision
        if (player.x + player.width > enemy.x && player.x < enemy.x + 24 &&
            player.y + player.height > enemy.y && player.y < enemy.y + 28) {
            
            // Stomp check
            if (player.vy > 50 && player.y + player.height < enemy.y + 18) {
                enemy.health = 0;
                player.vy = -350;
                totalScore += 150;
                SFX.stomp();
                spawnParticles(enemy.x + 12, enemy.y + 14, currentLevelData.enemyColor, 20, 150, 0.6, 5);
                screenShake = 0.15;
            } else if (player.invincible <= 0) {
                damagePlayer();
                player.vx = player.x < enemy.x ? -250 : 250;
                player.vy = -200;
                if (player.health <= 0) return;
            }
        }
    }
    
    // Boss update
    if (boss && !bossDefeated) {
        updateBoss(eDt);
    }
    
    // Projectile update
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.x += p.vx * eDt;
        p.y += p.vy * eDt;
        p.life -= eDt;
        
        if (p.life <= 0 || p.x < -20 || p.x > WIDTH + 20 || p.y < -20 || p.y > HEIGHT + 20) {
            projectiles.splice(i, 1);
            continue;
        }
        
        // Trail
        if (Math.random() < 0.5) {
            spawnTrail(p.x, p.y, p.hostile ? '#ff44ff' : '#44ff44');
        }
        
        // Hit player
        if (p.hostile && player.invincible <= 0 &&
            player.x + player.width > p.x - 6 && player.x < p.x + 6 &&
            player.y + player.height > p.y - 6 && player.y < p.y + 6) {
            damagePlayer();
            spawnParticles(p.x, p.y, '#ff0044', 10, 100, 0.4, 4);
            projectiles.splice(i, 1);
            if (player.health <= 0) return;
        }
    }
    
    // Collectibles
    for (const c of collectibles) {
        if (c.collected) continue;
        
        const cx = c.x + 10;
        const cy = c.y + 10 + Math.sin(gameTime * 3 + c.x) * 4;
        
        if (player.x + player.width > c.x && player.x < c.x + 20 &&
            player.y + player.height > cy - 10 && player.y < cy + 10) {
            c.collected = true;
            collectedCount++;
            totalScore += 100;
            SFX.collect();
            spawnParticles(cx, cy, currentLevelData.accentColor, 15, 120, 0.6, 5, 'star');
        }
    }
    
    // Goal
    const goal = currentLevelData.goal;
    if (!boss || bossDefeated) {
        if (player.x + player.width > goal.x && player.x < goal.x + goal.w &&
            player.y + player.height > goal.y && player.y < goal.y + goal.h) {
            levelComplete();
            return;
        }
    }
    
    // Clear pressed keys
    Object.keys(keysPressed).forEach(k => keysPressed[k] = false);
    
    // Update particles
    updateParticles(eDt);
    
    // Screen effects decay
    screenShake *= 0.9;
    screenFlash *= 0.9;
}

function damagePlayer() {
    player.health--;
    player.invincible = 1.5;
    screenShake = 0.3;
    screenFlash = 0.2;
    screenFlashColor = '#ff0000';
    SFX.hurt();
    spawnParticles(player.x + player.width/2, player.y + player.height/2, '#ff4444', 15, 120, 0.5, 4);
    
    if (player.health <= 0) {
        playerDeath();
    }
}

function updateBoss(dt) {
    if (!boss || bossDefeated) return;
    
    const gameTime = performance.now() / 1000;
    
    // Boss movement pattern
    boss.x = 400 + Math.sin(gameTime * 1.5) * 150;
    boss.y = 80 + Math.sin(gameTime * 2) * 40;
    
    // Boss shooting based on phase
    if (!boss.shootTimer) boss.shootTimer = 0;
    boss.shootTimer -= dt;
    
    if (boss.shootTimer <= 0) {
        const shootCount = boss.phase === 1 ? 3 : (boss.phase === 2 ? 5 : 8);
        boss.shootTimer = boss.phase === 1 ? 1.5 : (boss.phase === 2 ? 1.2 : 0.8);
        
        for (let i = 0; i < shootCount; i++) {
            const angle = (Math.PI * 2 / shootCount) * i + gameTime;
            projectiles.push({
                x: boss.x + 40, y: boss.y + 40,
                vx: Math.cos(angle) * 150,
                vy: Math.sin(angle) * 150,
                hostile: true, life: 4
            });
        }
        SFX.shoot();
    }
    
    // Boss damage from stomp
    if (player.vy > 50 && player.invincible <= 0 &&
        player.x + player.width > boss.x && player.x < boss.x + 80 &&
        player.y + player.height > boss.y && player.y < boss.y + 80 &&
        player.y + player.height < boss.y + 50) {
        
        boss.health--;
        player.vy = -400;
        player.invincible = 0.5;
        screenShake = 0.4;
        SFX.stomp();
        spawnParticles(boss.x + 40, boss.y + 40, '#ff00ff', 30, 200, 0.8, 6);
        
        // Update phase
        if (boss.health <= 6 && boss.phase === 1) {
            boss.phase = 2;
            SFX.powerUp();
        } else if (boss.health <= 3 && boss.phase === 2) {
            boss.phase = 3;
            SFX.powerUp();
        }
        
        if (boss.health <= 0) {
            bossDefeated = true;
            totalScore += 1000;
            SFX.victory();
            spawnParticles(boss.x + 40, boss.y + 40, '#ffff00', 50, 250, 1.2, 8, 'star');
            screenFlash = 0.5;
            screenFlashColor = '#ffff00';
        }
    }
    
    // Boss collision damage
    if (player.invincible <= 0 &&
        player.x + player.width > boss.x + 10 && player.x < boss.x + 70 &&
        player.y + player.height > boss.y + 10 && player.y < boss.y + 70) {
        damagePlayer();
        player.vx = player.x < boss.x + 40 ? -300 : 300;
        player.vy = -250;
    }
}

function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(dt);
        if (particles[i].life <= 0) particles.splice(i, 1);
    }
}

// ============================================================================
// RENDERING
// ============================================================================
function draw() {
    ctx.save();
    
    // Screen shake
    if (screenShake > 0.01) {
        ctx.translate(
            (Math.random() - 0.5) * screenShake * 25,
            (Math.random() - 0.5) * screenShake * 25
        );
    }
    
    // Background
    drawBackground();
    
    if (gameState === 'playing' || gameState === 'paused' || gameState === 'dead' || gameState === 'levelComplete') {
        drawGame();
    }
    
    ctx.restore();
    
    // Screen flash (not affected by shake)
    if (screenFlash > 0.01) {
        ctx.fillStyle = screenFlashColor;
        ctx.globalAlpha = screenFlash * 0.4;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        ctx.globalAlpha = 1;
    }
    
    // UI
    if (gameState === 'playing') {
        drawUI();
    }
}

function drawBackground() {
    const colors = currentLevelData ? currentLevelData.bgGradient : ['#1a0a2e', '#2d1b4e', '#1a2a1a'];
    const grad = ctx.createLinearGradient(0, 0, 0, HEIGHT);
    grad.addColorStop(0, colors[0]);
    grad.addColorStop(0.5, colors[1]);
    grad.addColorStop(1, colors[2]);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, WIDTH, HEIGHT);
    
    // Parallax stars
    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
    const time = performance.now() / 50;
    for (let i = 0; i < 60; i++) {
        const x = ((i * 47 + time * 0.1) % (WIDTH + 20)) - 10;
        const y = (i * 73) % HEIGHT;
        const size = (i % 3) + 1;
        ctx.fillRect(x, y, size, size);
    }
    
    // Deeper stars
    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
    for (let i = 0; i < 40; i++) {
        const x = ((i * 61 + time * 0.05) % (WIDTH + 20)) - 10;
        const y = (i * 89 + 50) % HEIGHT;
        ctx.fillRect(x, y, 1, 1);
    }
}

function drawGame() {
    const gameTime = performance.now() / 1000;
    
    // Hazards
    for (const h of hazards) {
        ctx.fillStyle = '#cc2222';
        for (let i = 0; i < h.w; i += 14) {
            ctx.beginPath();
            ctx.moveTo(h.x + i, h.y + h.h);
            ctx.lineTo(h.x + i + 7, h.y);
            ctx.lineTo(h.x + i + 14, h.y + h.h);
            ctx.fill();
        }
    }
    
    // Platforms
    for (const p of platforms) {
        // Shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(p.x + 4, p.y + 4, p.w, p.h);
        
        // Main
        ctx.fillStyle = currentLevelData.platformColor;
        ctx.fillRect(p.x, p.y, p.w, p.h);
        
        // Highlight
        ctx.fillStyle = currentLevelData.platformHighlight;
        ctx.fillRect(p.x, p.y, p.w, 4);
        
        // Edge detail
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.fillRect(p.x, p.y + p.h - 3, p.w, 3);
        
        // Moving platform indicator
        if (p.moving) {
            ctx.fillStyle = currentLevelData.accentColor;
            ctx.globalAlpha = 0.5 + Math.sin(gameTime * 4) * 0.3;
            ctx.fillRect(p.x + p.w/2 - 10, p.y + 2, 20, 2);
            ctx.globalAlpha = 1;
        }
    }
    
    // Goal portal
    const goal = currentLevelData.goal;
    const goalActive = !boss || bossDefeated;
    if (goalActive) {
        const pulse = Math.sin(gameTime * 4) * 0.3 + 0.7;
        
        // Glow
        ctx.fillStyle = currentLevelData.accentColor;
        ctx.globalAlpha = pulse * 0.3;
        ctx.fillRect(goal.x - 10, goal.y - 10, goal.w + 20, goal.h + 20);
        ctx.globalAlpha = 1;
        
        // Portal
        const portalGrad = ctx.createLinearGradient(goal.x, goal.y, goal.x, goal.y + goal.h);
        portalGrad.addColorStop(0, currentLevelData.accentColor);
        portalGrad.addColorStop(0.5, '#ffffff');
        portalGrad.addColorStop(1, currentLevelData.accentColor);
        ctx.fillStyle = portalGrad;
        ctx.fillRect(goal.x, goal.y, goal.w, goal.h);
        
        // Border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.strokeRect(goal.x, goal.y, goal.w, goal.h);
        
        // Inner swirl
        ctx.strokeStyle = currentLevelData.accentColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let i = 0; i < 20; i++) {
            const t = i / 20;
            const r = 15 * (1 - t);
            const angle = t * Math.PI * 4 + gameTime * 3;
            const x = goal.x + goal.w/2 + Math.cos(angle) * r;
            const y = goal.y + goal.h/2 + Math.sin(angle) * r * 1.5;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }
    
    // Collectibles
    for (const c of collectibles) {
        if (c.collected) continue;
        
        const bob = Math.sin(gameTime * 3 + c.x * 0.1) * 4;
        const cx = c.x + 10;
        const cy = c.y + 10 + bob;
        const pulse = Math.sin(gameTime * 5 + c.x) * 0.2 + 0.8;
        
        // Glow
        ctx.fillStyle = currentLevelData.accentColor;
        ctx.globalAlpha = 0.3 * pulse;
        ctx.beginPath();
        ctx.arc(cx, cy, 14, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        
        // Orb
        const orbGrad = ctx.createRadialGradient(cx - 3, cy - 3, 0, cx, cy, 10);
        orbGrad.addColorStop(0, '#ffffff');
        orbGrad.addColorStop(0.5, currentLevelData.accentColor);
        orbGrad.addColorStop(1, currentLevelData.platformColor);
        ctx.fillStyle = orbGrad;
        ctx.beginPath();
        ctx.arc(cx, cy, 9, 0, Math.PI * 2);
        ctx.fill();
        
        // Shine
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.arc(cx - 3, cy - 3, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Enemies
    for (const e of enemies) {
        if (e.health <= 0) continue;
        
        const bounce = Math.sin(gameTime * 8 + e.x) * 2;
        
        if (e.type === 'walker') {
            // Body
            ctx.fillStyle = currentLevelData.enemyColor;
            ctx.fillRect(e.x, e.y + bounce, 24, 28);
            
            // Darker bottom
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.fillRect(e.x, e.y + 20 + bounce, 24, 8);
            
            // Eye
            ctx.fillStyle = '#ffffff';
            const eyeX = e.vx > 0 ? e.x + 14 : e.x + 4;
            ctx.fillRect(eyeX, e.y + 8 + bounce, 8, 8);
            
            // Pupil
            ctx.fillStyle = '#000000';
            const pupilOffset = e.vx > 0 ? 4 : 0;
            ctx.fillRect(eyeX + pupilOffset + 1, e.y + 11 + bounce, 3, 4);
            
            // Angry brow
            ctx.fillStyle = currentLevelData.enemyColor;
            ctx.fillRect(eyeX - 1, e.y + 6 + bounce, 10, 3);
        } else if (e.type === 'shooter') {
            // Body
            ctx.fillStyle = currentLevelData.enemyColor;
            ctx.fillRect(e.x, e.y, 28, 28);
            
            // Tech pattern
            ctx.fillStyle = currentLevelData.accentColor;
            ctx.globalAlpha = 0.5 + Math.sin(gameTime * 6) * 0.3;
            ctx.fillRect(e.x + 4, e.y + 4, 20, 2);
            ctx.fillRect(e.x + 4, e.y + 22, 20, 2);
            ctx.globalAlpha = 1;
            
            // Eye
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(e.x + 14, e.y + 14, 7, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner eye
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(e.x + 14, e.y + 14, 4, 0, Math.PI * 2);
            ctx.fill();
            
            // Targeting light
            ctx.fillStyle = '#ff0000';
            ctx.globalAlpha = Math.sin(gameTime * 10) * 0.5 + 0.5;
            ctx.beginPath();
            ctx.arc(e.x + 14, e.y + 14, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }
    
    // Boss
    if (boss && !bossDefeated) {
        drawBoss();
    }
    
    // Projectiles
    for (const p of projectiles) {
        ctx.fillStyle = p.hostile ? '#ff00ff' : '#00ff00';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Player
    drawPlayer();
    
    // Particles
    for (const p of particles) {
        p.draw();
    }
    
    // Time effects
    if (timeScale < 0.9) {
        // Slow-mo overlay
        ctx.fillStyle = 'rgba(0, 100, 150, 0.12)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        
        // Scanlines
        ctx.fillStyle = 'rgba(0, 200, 255, 0.04)';
        for (let y = 0; y < HEIGHT; y += 4) {
            ctx.fillRect(0, y, WIDTH, 2);
        }
        
        // Vignette
        const vigGrad = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, 100, WIDTH/2, HEIGHT/2, 500);
        vigGrad.addColorStop(0, 'rgba(0, 255, 255, 0)');
        vigGrad.addColorStop(1, 'rgba(0, 100, 150, 0.3)');
        ctx.fillStyle = vigGrad;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
    }
    
    if (isRewinding) {
        // Rewind overlay
        ctx.fillStyle = 'rgba(150, 0, 150, 0.15)';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        
        // Chromatic lines
        ctx.strokeStyle = 'rgba(255, 0, 255, 0.2)';
        ctx.lineWidth = 1;
        for (let i = 0; i < 10; i++) {
            const y = (gameTime * 500 + i * 60) % (HEIGHT + 100) - 50;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(WIDTH, y + 50);
            ctx.stroke();
        }
    }
}

function drawPlayer() {
    if (player.invincible > 0 && Math.floor(player.invincible * 10) % 2 === 0) return;
    
    const px = player.x;
    const py = player.y;
    const gameTime = performance.now() / 1000;
    
    // Time power glow
    if (timeScale < 0.9) {
        ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
        ctx.fillRect(px - 6, py - 6, player.width + 12, player.height + 12);
    }
    if (isRewinding) {
        ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
        ctx.fillRect(px - 6, py - 6, player.width + 12, player.height + 12);
    }
    
    ctx.save();
    if (!player.facingRight) {
        ctx.translate(px + player.width/2, 0);
        ctx.scale(-1, 1);
        ctx.translate(-(px + player.width/2), 0);
    }
    
    const legAnim = player.state === 'run' ? Math.sin(player.animFrame * 1.5) * 4 : 0;
    const breathe = player.state === 'idle' ? Math.sin(gameTime * 2) * 1 : 0;
    
    // Shadow
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.beginPath();
    ctx.ellipse(px + player.width/2, py + player.height + 2, 12, 4, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Legs
    ctx.fillStyle = '#2a4466';
    ctx.fillRect(px + 5, py + 26, 7, 10 + legAnim);
    ctx.fillRect(px + 16, py + 26, 7, 10 - legAnim);
    
    // Body
    ctx.fillStyle = '#4488cc';
    ctx.fillRect(px + 4, py + 10 + breathe, 20, 18);
    
    // Chest highlight
    ctx.fillStyle = '#66aaee';
    ctx.fillRect(px + 6, py + 12 + breathe, 6, 8);
    
    // Time device (chest)
    ctx.fillStyle = timeScale < 0.9 ? '#00ffff' : (isRewinding ? '#ff00ff' : '#aaddff');
    ctx.beginPath();
    ctx.arc(px + 14, py + 18 + breathe, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Head
    ctx.fillStyle = '#ffcc99';
    ctx.fillRect(px + 6, py + breathe, 16, 14);
    
    // Hair
    ctx.fillStyle = '#443322';
    ctx.fillRect(px + 5, py - 2 + breathe, 18, 6);
    ctx.fillRect(px + 4, py + 2 + breathe, 4, 4);
    
    // Eyes
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(px + 10, py + 5 + breathe, 5, 5);
    ctx.fillRect(px + 17, py + 5 + breathe, 5, 5);
    
    // Pupils
    ctx.fillStyle = '#000000';
    const lookOffset = player.state === 'jump' ? -1 : (player.state === 'fall' ? 1 : 0);
    ctx.fillRect(px + 12, py + 7 + breathe + lookOffset, 2, 2);
    ctx.fillRect(px + 19, py + 7 + breathe + lookOffset, 2, 2);
    
    // Arms
    const armAnim = player.state === 'run' ? Math.sin(player.animFrame * 1.5 + Math.PI) * 3 : 0;
    ctx.fillStyle = '#ffcc99';
    ctx.fillRect(px, py + 12 + breathe + armAnim, 5, 12);
    ctx.fillRect(px + 23, py + 12 + breathe - armAnim, 5, 12);
    
    ctx.restore();
}

function drawBoss() {
    const gameTime = performance.now() / 1000;
    const pulse = Math.sin(gameTime * 3) * 0.2 + 0.8;
    const shake = boss.health < 4 ? Math.sin(gameTime * 20) * 3 : 0;
    
    // Glow based on phase
    const glowColor = boss.phase === 1 ? '#8800ff' : (boss.phase === 2 ? '#ff00ff' : '#ff0000');
    ctx.fillStyle = glowColor;
    ctx.globalAlpha = 0.3 * pulse;
    ctx.beginPath();
    ctx.arc(boss.x + 40 + shake, boss.y + 40, 60, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
    
    // Body
    ctx.fillStyle = '#3a1a5a';
    ctx.fillRect(boss.x + shake, boss.y, 80, 80);
    
    // Inner pattern
    ctx.fillStyle = glowColor;
    ctx.globalAlpha = 0.5 + Math.sin(gameTime * 5) * 0.3;
    ctx.fillRect(boss.x + 10 + shake, boss.y + 10, 60, 5);
    ctx.fillRect(boss.x + 10 + shake, boss.y + 65, 60, 5);
    ctx.fillRect(boss.x + 10 + shake, boss.y + 10, 5, 60);
    ctx.fillRect(boss.x + 65 + shake, boss.y + 10, 5, 60);
    ctx.globalAlpha = 1;
    
    // Eye
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(boss.x + 40 + shake, boss.y + 40, 25, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = glowColor;
    ctx.beginPath();
    ctx.arc(boss.x + 40 + shake, boss.y + 40, 18, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(boss.x + 40 + shake, boss.y + 40, 10, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(boss.x + 35 + shake, boss.y + 35, 5, 0, Math.PI * 2);
    ctx.fill();
    
    // Health bar
    const healthPct = boss.health / boss.maxHealth;
    ctx.fillStyle = '#333';
    ctx.fillRect(boss.x, boss.y - 20, 80, 10);
    ctx.fillStyle = glowColor;
    ctx.fillRect(boss.x, boss.y - 20, 80 * healthPct, 10);
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.strokeRect(boss.x, boss.y - 20, 80, 10);
}

function drawUI() {
    // Health
    for (let i = 0; i < player.maxHealth; i++) {
        const x = 20 + i * 35;
        const y = 20;
        
        if (i < player.health) {
            // Full heart
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.moveTo(x + 12, y + 6);
            ctx.bezierCurveTo(x + 12, y + 2, x + 6, y, x + 6, y + 6);
            ctx.bezierCurveTo(x + 6, y + 12, x + 12, y + 18, x + 12, y + 22);
            ctx.bezierCurveTo(x + 12, y + 18, x + 18, y + 12, x + 18, y + 6);
            ctx.bezierCurveTo(x + 18, y, x + 12, y + 2, x + 12, y + 6);
            ctx.fill();
            
            // Shine
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(x + 8, y + 7, 3, 0, Math.PI * 2);
            ctx.fill();
        } else {
            // Empty heart
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 12, y + 6);
            ctx.bezierCurveTo(x + 12, y + 2, x + 6, y, x + 6, y + 6);
            ctx.bezierCurveTo(x + 6, y + 12, x + 12, y + 18, x + 12, y + 22);
            ctx.bezierCurveTo(x + 12, y + 18, x + 18, y + 12, x + 18, y + 6);
            ctx.bezierCurveTo(x + 18, y, x + 12, y + 2, x + 12, y + 6);
            ctx.stroke();
        }
    }
    
    // Time energy bar
    const barX = 20, barY = 50, barW = 150, barH = 14;
    
    // Background
    ctx.fillStyle = '#222';
    ctx.fillRect(barX, barY, barW, barH);
    
    // Energy fill
    const energyPct = timeEnergy / MAX_TIME_ENERGY;
    const energyColor = timeScale < 0.9 ? '#00ffff' : (isRewinding ? '#ff00ff' : '#4488ff');
    const energyGrad = ctx.createLinearGradient(barX, barY, barX + barW, barY);
    energyGrad.addColorStop(0, energyColor);
    energyGrad.addColorStop(1, '#ffffff');
    ctx.fillStyle = energyGrad;
    ctx.fillRect(barX, barY, barW * energyPct, barH);
    
    // Border
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(barX, barY, barW, barH);
    
    // Label
    ctx.fillStyle = '#888';
    ctx.font = '10px Orbitron';
    ctx.fillText('TIME ENERGY', barX, barY - 4);
    
    // Score
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px Orbitron';
    ctx.textAlign = 'right';
    ctx.fillText(totalScore.toLocaleString(), WIDTH - 20, 35);
    ctx.font = '10px Orbitron';
    ctx.fillStyle = '#888';
    ctx.fillText('SCORE', WIDTH - 20, 20);
    ctx.textAlign = 'left';
    
    // Orbs collected
    ctx.fillStyle = currentLevelData.accentColor;
    ctx.font = '12px Orbitron';
    ctx.fillText(`${collectedCount}/${totalCollectibles}`, WIDTH - 60, 55);
    ctx.beginPath();
    ctx.arc(WIDTH - 75, 52, 6, 0, Math.PI * 2);
    ctx.fill();
    
    // Level name
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.font = '11px Orbitron';
    ctx.fillText(currentLevelData.name, 20, HEIGHT - 15);
    
    // Time
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.textAlign = 'right';
    ctx.fillText(formatTime(levelTime), WIDTH - 20, HEIGHT - 15);
    ctx.textAlign = 'left';
    
    // Power indicators
    if (timeScale < 0.9) {
        ctx.fillStyle = '#00ffff';
        ctx.font = 'bold 14px Orbitron';
        ctx.fillText('[ TIME SLOW ]', WIDTH / 2 - 50, 30);
    } else if (isRewinding) {
        ctx.fillStyle = '#ff00ff';
        ctx.font = 'bold 14px Orbitron';
        ctx.fillText('[ REWINDING ]', WIDTH / 2 - 50, 30);
    }
    
    // Controls hint
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.font = '10px Orbitron';
    ctx.textAlign = 'center';
    ctx.fillText('WASD: Move  |  SHIFT: Time Slow  |  R: Rewind  |  ESC: Pause', WIDTH / 2, HEIGHT - 5);
    ctx.textAlign = 'left';
}

// ============================================================================
// GAME LOOP
// ============================================================================
let lastTime = performance.now();

function gameLoop() {
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;
    
    update(dt);
    draw();
    
    requestAnimationFrame(gameLoop);
}

// Start
loadLevel(0);
gameLoop();
    </script>
</body>
</html>
